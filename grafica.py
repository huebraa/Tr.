# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wLPKhSIUvy0RM3p8viFL_p2TMDoGFLFj
"""



import pandas as pd
from google.colab import files
from PIL import Image
import plotly.graph_objects as go
import io
import base64

# Definir las etiquetas del eje X (de 21.5 a 38.5) con subdivisiones de 0.1
x_labels = [f'{21.5 + i/10:.1f}' for i in range(171)]  # De 21.5 a 38.5
x_values = [i / (len(x_labels) - 1) for i in range(len(x_labels))]  # Valores normalizados de 0 a 1

# Definir las etiquetas del eje Y (de O a X) con subdivisiones
y_main_labels = ['O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X']  # Letras principales
y_labels = [f'{letter}.{i}' if i > 0 else letter for letter in y_main_labels for i in range(10)]  # Subdivisiones
y_values = [i / (len(y_labels) - 1) for i in range(len(y_labels))]  # Valores normalizados de 0 a 1

# Función para convertir etiquetas de coordenadas X a valores numéricos
def x_to_numeric(x_label):
    try:
        x_label_str = f"{float(x_label):.1f}"
        index = x_labels.index(x_label_str)
        return x_values[index]
    except ValueError:
        return None

# Función para convertir etiquetas de coordenadas Y (letras + subdivisiones) a valores numéricos
def y_to_numeric(y_label):
    try:
        index = y_labels.index(str(y_label).upper())
        return y_values[index]
    except ValueError:
        return None

# Cargar el archivo Excel desde el ordenador
print("Por favor, sube el archivo Excel con la información de los puntos:")
uploaded_excel = files.upload()

# Leer el archivo Excel en un DataFrame
excel_filename = list(uploaded_excel.keys())[0]
data = pd.read_excel(excel_filename)

# Cargar la imagen desde el ordenador
print("Por favor, sube la imagen que quieres usar:")
uploaded_image = files.upload()

# Obtener el nombre del archivo de la imagen cargada
image_path = list(uploaded_image.keys())[0]

# Abrir la imagen usando PIL
image = Image.open(image_path)

# Convertir la imagen a base64 para que plotly la acepte
with io.BytesIO() as buffer:
    image.save(buffer, format="PNG")
    img_str = base64.b64encode(buffer.getvalue()).decode()

# Definir la fuente de la imagen en formato base64
img_base64 = "data:image/png;base64," + img_str

# Obtener dimensiones de la imagen (sin escalado)
img_width, img_height = image.size

# Convertir las coordenadas de X e Y del archivo Excel a sus valores numéricos
data['X_numeric'] = data['X'].apply(x_to_numeric)
data['Y_numeric'] = data['Y'].apply(y_to_numeric)

# Filtrar filas donde las coordenadas sean válidas (no None)
valid_data = data.dropna(subset=['X_numeric', 'Y_numeric'])

# Crear la figura con la imagen de fondo sin escalado
fig = go.Figure()

# Añadir la imagen de fondo
fig.add_layout_image(
    dict(
        source=img_base64,  # La imagen en formato base64
        xref="x",  # Referencias de los ejes
        yref="y",
        x=0,
        y=img_height,
        sizex=img_width,
        sizey=img_height,
        sizing="stretch",
        opacity=1,
        layer="below")
)

# Añadir los puntos interactivos sobre la imagen desde los datos del Excel, diferenciando colores
for _, row in valid_data.iterrows():
    color = 'red' if row['Tipo'].lower() == 'principal' else 'blue'  # Asignar color según tipo
    fig.add_trace(go.Scatter(
        x=[row['X_numeric'] * img_width],  # Escalar la coordenada X
        y=[row['Y_numeric'] * img_height],  # Escalar la coordenada Y
        mode='markers',
        hovertemplate='<b>%{customdata[0]}</b><extra></extra>',  # Mostrar solo la información
        customdata=[[row['Información']]],  # Cambiar a lista anidada
        marker=dict(size=5, color=color)  # Tamaño 5 y color según el tipo
    ))

# Configurar los ejes para que se ajusten a la imagen sin escalado
fig.update_xaxes(
    visible=True,
    range=[0, img_width],
    tickvals=[x * img_width for x in x_values[::10]],  # Usamos las etiquetas más simples, cada 1.0
    ticktext=[x_labels[i] for i in range(len(x_labels)) if x_labels[i].endswith('0')],  # Solo mostramos las divisiones principales
    scaleanchor="y",
    showgrid=False,  # Deshabilitar líneas de cuadrícula
)

fig.update_yaxes(
    visible=True,
    range=[0, img_height],
    tickvals=[y * img_height for y in y_values[::10]],  # Solo colocamos ticks para letras principales
    ticktext=y_main_labels,  # Mostramos las letras principales
    showgrid=False,  # Deshabilitar líneas de cuadrícula
)

# Mostrar la figura
fig.show()